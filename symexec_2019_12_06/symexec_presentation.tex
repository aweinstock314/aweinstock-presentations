\documentclass[aspectratio=169]{beamer}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{tikz}
\usepackage{fancyvrb}
\usepackage{xcolor}
\title{Symbolic Execution with Angr\\RPISEC}
\date{December 6, 2019}
\author{Avi Weinstock (\Verb|aweinstock|), Luke Biery (\Verb|tiecoon|)}

\input{../rpisec_beamer_theme.tex}

\begin{document}
\maketitle

\begin{frame}[fragile]
\frametitle{Overview}
\begin{itemize}
\item What is Symbolic Execution? What techniques does it compete with?
\item How symbolic execution works (theory)
\item How symbolic execution works (Angr commands)
\item Solving MBE lab1A with Angr
\end{itemize}
\end{frame}

\section{Background - What it is and what is the problem space?}
\begin{frame}[fragile]
\frametitle{What is Symbolic Execution?}
\begin{itemize}
\item Executes a program with symbolic data (usually input)
\item Essentially runs a program on "all possible inputs" at once
\item Instead of having concrete data in each variable/address, \\variables/addresses store trees of what to do with the input
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{What problems does Symbolic Execution solve?}
\begin{itemize}
\item What input to provide to reach/avoid a specific line of code?
\item How is a value deep in the program affected by some specific input?
\item Do any inputs lead to any crash?
\item On a crashing input, what registers are controlled by the input?
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Symbolic Execution vs Fuzzing}
\begin{tabular}{c|c}
Symbolic Execution & Fuzzing\\\hline
\textcolor{green}{+ Explores all inputs} & \textcolor{red}{- Only explores random inputs}\\
\textcolor{green}{+ Very detailed output} & \textcolor{red}{- Only learn crash vs non-crash}\\
\textcolor{red}{- Uses more memory/time} & \textcolor{green}{+ Uses around as much memory/time as target program}
\end{tabular}
TODO: more comparisons/columns? emphasize that "all inputs" means that symexec can find constant-time comparisons against a giant constant, unlike coverage-guided?
\end{frame}

\section{How symbolic execution works in general}

\begin{frame}[fragile]
\frametitle{Setting up a state for symbolic execution}
\begin{itemize}
\item \begin{Verbatim}[fontsize=\scriptsize, frame=single]
import z3
registers = ['eax', 'ebx', 'ecx', 'edx', 'ebp', 'esp'] # and so on
symstate = {reg: z3.BitVec(reg, 32) for reg in registers}
symstate['memory'] = z3.Array('memory', z3.BitVecSort(32), z3.BitVecSort(8))
\end{Verbatim}
\item Note that the z3 variable \verb|eax| in the model will be the starting value of \verb|eax|
\item \verb|symstate['eax']| will be mutated throughout the computation, and will contain an expression corresponding to the ending value of \verb|eax|
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Symbolically executing branch-free code}
\begin{itemize}
\item Translate arithmetic, indexing, etc into SMT constraints
\end{itemize}
\begin{minipage}{0.3\textwidth}
\begin{Verbatim}[fontsize=\scriptsize, frame=single]
mov eax, ebx
\end{Verbatim}
\end{minipage}
\begin{minipage}{0.68\textwidth}
\begin{Verbatim}[fontsize=\scriptsize, frame=single]
symstate['eax'] = symstate['ebx']
\end{Verbatim}
\end{minipage}

\begin{minipage}{0.3\textwidth}
\begin{Verbatim}[fontsize=\scriptsize, frame=single]
add ecx, edx
\end{Verbatim}
\end{minipage}
\begin{minipage}{0.68\textwidth}
\begin{Verbatim}[fontsize=\scriptsize, frame=single]
symstate['ecx'] += symstate['edx']
\end{Verbatim}
\end{minipage}

\begin{minipage}{0.3\textwidth}
\begin{Verbatim}[fontsize=\scriptsize, frame=single]
mov byte [esp+0x10], al
\end{Verbatim}
\end{minipage}
\begin{minipage}{0.68\textwidth}
\begin{Verbatim}[fontsize=\scriptsize, frame=single]
esp_10 = symstate['esp']+0x10
al = z3.Extract(7, 0, symstate['eax'])
symstate['memory'] = z3.Store(symstate['memory'], esp_10, al)
\end{Verbatim}
\end{minipage}

\begin{minipage}{0.3\textwidth}
\begin{Verbatim}[fontsize=\scriptsize, frame=single]
movsx eax, byte [eax]
\end{Verbatim}
\end{minipage}
\begin{minipage}{0.68\textwidth}
\begin{Verbatim}[fontsize=\scriptsize, frame=single]
star_eax = z3.Select(symstate['memory'], eax)
symstate['eax'] = z3.SignExt(24, star_eax)
\end{Verbatim}
\end{minipage}
\end{frame}

\begin{frame}[fragile]
\frametitle{Symbolically executing branchs - Graphically}
\begin{minipage}{0.25\textwidth}
\begin{Verbatim}[fontsize=\scriptsize, frame=single]
int f(int x, int y) {
    if (x > 3) {
        x += 1;
    } else {
        y = 2*y+3;
    }
    if(y != 0) {
        x /= y;
    } else {
        x *= 2;
    }
    return x + y;
}
\end{Verbatim}
\end{minipage}
\begin{minipage}{0.6\textwidth}
\begin{tikzpicture}
\draw (-1.5,5) rectangle node{$x = x_0$, $y = y_0$} (1.5,4);

\draw[green, ->] (-1,4) -- node[left]{$x > 3$} (-1.5, 3.5); 
\draw (-3.5,3.5) rectangle node{$x = x_0+1$, $y = y_0$} (-0.5,2.5);
\draw[red, ->] (1,4) -- node[right]{$x \le 3$} (1.5, 3.5); 
\draw (0.5,3.5) rectangle node{$x = x_0$, $y = 2*y_0+3$} (4.5,2.5);

\draw[green, ->] (-3,2.5) -- node[left]{$y \neq 0$} (-4, 2); 
\draw (-5, 2) rectangle node[above]{$x = \frac{x_0+1}{y_0}$} node[below]{$y = y_0$} (-3.1, 0.5);
\draw[red, ->] (-1,2.5) -- node[left]{$y = 0$} (-1, 2); 
\draw (-2.9, 2) rectangle node[above]{$x = 2*(x_0+1)$} node[below]{$y = 0$} (-0, 0.5);

\draw[green, ->] (1,2.5) -- node[left]{$y \neq 0$} (1, 2); 
\draw (2.9, 2) rectangle node[above]{$x = \frac{x_0}{2*y_0+3}$} node[below]{$y = 2*y_0+3$} (0.1, 0.5);
\draw[red, ->] (3,2.5) -- node[left]{$y = 0$} (4, 2); 
\draw (5, 2) rectangle node[above]{$x = 2*x_0$} node[below]{$y = 0$} (3.1, 0.5);
\end{tikzpicture}
\end{minipage}
\end{frame}

\begin{frame}[fragile]
\frametitle{Symbolically executing branchs - Programmatically}
\begin{minipage}{0.25\textwidth}
\begin{Verbatim}[fontsize=\scriptsize, frame=single]
int f(int x, int y) {
    if (x > 3) {
        x += 1;
    } else {
        y = 2*y+3;
    }
    if(y != 0) {
        x /= y;
    } else {
        x *= 2;
    }
    return x + y;
}
\end{Verbatim}
\end{minipage}
\begin{minipage}{0.74\textwidth}
\begin{Verbatim}[fontsize=\scriptsize, frame=single]
import z3
x0, y0 = z3.Ints('x0 y0')
states, newstates = [(x0, y0, z3.Solver())], []
for (x, y, s) in states:
  t = s.__deepcopy__()
  s.add(x > 3); newstates.append((x+1, y, s))
  t.add(z3.Not(x > 3)); newstates.append((x, 2*y+3, t))

states, newstates = newstates, []
for (x, y, s) in states:
  t = s.__deepcopy__()
  s.add(y != 0); newstates.append((x/y, y, s))
  t.add(z3.Not(y != 0)); newstates.append((2*x, y, t))

for (x, y, s) in newstates:
  print('x: %r; y: %r; s: %r; check: %r' % (x, y, s, s.check()))
  if s.check() == z3.sat:
    m = s.model()
    print('m: %r; x: %r; y: %r' % (m, m.evaluate(x), m.evaluate(y)))
    print('-'*5)
\end{Verbatim}
\end{minipage}
\end{frame}

\begin{frame}[fragile]
\frametitle{TODO: Avi}
\begin{itemize}
\item symbolic loops
\item symbolizing tainted memory (e.g. \verb|sym_memory[(EBP+username+i)]| vs \verb|sym_username[i]|)
\item state explosion when looping on symbolic data
\end{itemize}
\end{frame}

\section{How to use Angr for symbolic execution}
\begin{frame}[fragile]
\frametitle{TODO: Luke}
\begin{itemize}
\item loading binariess
\item marking input as symbolic
\item initiating the search/pruning the search space
\item simprocedures for shortcutting syscalls?
\end{itemize}
\end{frame}

\section{Example: MBE lab1A with Angr}
\begin{frame}[fragile]
\frametitle{Resources}
\begin{itemize}
\item \verb|https://github.com/angr/|
\item \verb|https://github.com/Z3Prover/z3/|
\item \verb|https://github.com/RPISEC/MBE|
\end{itemize}
\end{frame}
\end{document}
